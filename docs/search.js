window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "sla", "modulename": "sla", "kind": "module", "doc": "<h1 id=\"simple-logs-analyzer-sla\">Simple Logs Analyzer (SLA)</h1>\n\n<p>A simple tool to analyze logs and extract meaningful insights.</p>\n"}, {"fullname": "sla.detectors", "modulename": "sla.detectors", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector", "modulename": "sla.detectors", "qualname": "AutoencoderDetector", "kind": "class", "doc": "<p>Autoencoder-based anomaly detector.</p>\n\n<p>This class implements an anomaly detector using an autoencoder\nfor detecting anomalies in time series data.</p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.__init__", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.__init__", "kind": "function", "doc": "<p>Initialize the autoencoder-based anomaly detector.</p>\n\n<p>Args:\n    n_features (int): Dimension of input features\n    seq_len (int): Length of input sequence\n    latent_dim (int): Dimension of the latent space representation\n    learning_rate (float): Learning rate for training the model\n    batch_size (int): Number of samples per batch\n    epochs (int): Number of epochs for training the model\n    threshold_multiplier (float): Anomaly threshold multiplier</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_features</span>,</span><span class=\"param\">\t<span class=\"n\">seq_len</span>,</span><span class=\"param\">\t<span class=\"n\">latent_dim</span><span class=\"o\">=</span><span class=\"mi\">20</span>,</span><span class=\"param\">\t<span class=\"n\">learning_rate</span><span class=\"o\">=</span><span class=\"mf\">0.001</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">32</span>,</span><span class=\"param\">\t<span class=\"n\">epochs</span><span class=\"o\">=</span><span class=\"mi\">20</span>,</span><span class=\"param\">\t<span class=\"n\">threshold_multiplier</span><span class=\"o\">=</span><span class=\"mf\">3.0</span></span>)</span>"}, {"fullname": "sla.detectors.AutoencoderDetector.n_features", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.n_features", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.seq_len", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.seq_len", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.latent_dim", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.latent_dim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.learning_rate", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.learning_rate", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.batch_size", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.batch_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.epochs", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.epochs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.threshold_multiplier", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.threshold_multiplier", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.device", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.device", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.model", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.optimizer", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.optimizer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.criterion", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.criterion", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.scaler", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.scaler", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.threshold", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.AutoencoderDetector.fit", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.fit", "kind": "function", "doc": "<p>Fit the anomaly detector to the input data.</p>\n\n<p>Args:\n    X (np.ndarray): Input data for training the model</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">X_test</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.AutoencoderDetector.predict", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.predict", "kind": "function", "doc": "<p>Predict anomalies in the input data.</p>\n\n<p>Args:\n    X (np.ndarray): Input data for anomaly detection</p>\n\n<p>Returns:\n    np.ndarray: Binary array where 1 indicates anomaly, 0 indicates normal</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.AutoencoderDetector.anomaly_score", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.anomaly_score", "kind": "function", "doc": "<p>Calculate anomaly scores for the input data.</p>\n\n<p>Args:\n    X (np.ndarray): Input data for anomaly detection</p>\n\n<p>Returns:\n    np.ndarray: Anomaly scores</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.AutoencoderDetector.save_model", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.save_model", "kind": "function", "doc": "<p>Save the model to disk.</p>\n\n<p>Args:\n    path (str): File path to save the model</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.AutoencoderDetector.load_model", "modulename": "sla.detectors", "qualname": "AutoencoderDetector.load_model", "kind": "function", "doc": "<p>Load the model from disk.</p>\n\n<p>Args:\n    path (str): File path to load the model</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.IsolationForestDetector", "modulename": "sla.detectors", "qualname": "IsolationForestDetector", "kind": "class", "doc": "<p>A detector for identifying anomalies using the Isolation Forest algorithm.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>n_estimators : int, optional (default=100)\n    The number of base estimators in the ensemble.\nmax_samples : int or float, optional (default='auto')\n    The number of samples to draw from X to train each base estimator.\n    If 'auto', then max_samples=min(256, n_samples).\ncontamination : 'auto' or float, optional (default='auto')\n    The amount of contamination of the data set, i.e., the proportion of outliers in the data set.\n    Used when fitting to define the threshold on the decision function.\n    If 'auto', the threshold is determined as in the original paper.\nrandom_state : int, RandomState instance or None, optional (default=None)\n    Controls the pseudo-randomness of the selection of the feature and split values for each branching step and each tree in the forest.\n    Pass an int for reproducible results across multiple function calls.</p>\n\n<h2 id=\"methods\">Methods</h2>\n\n<p>fit(X)\n    Fit the Isolation Forest model according to the given training data.\npredict(X)\n    Predict if a particular sample is an outlier or not.\ndecision_function(X)\n    Compute the anomaly score of each sample.</p>\n", "bases": "sklearn.base.BaseEstimator"}, {"fullname": "sla.detectors.IsolationForestDetector.__init__", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_estimators</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">max_samples</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">contamination</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "sla.detectors.IsolationForestDetector.n_estimators", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.n_estimators", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.IsolationForestDetector.max_samples", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.max_samples", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.IsolationForestDetector.contamination", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.contamination", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.IsolationForestDetector.random_state", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.random_state", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.IsolationForestDetector.model", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.IsolationForestDetector.fit", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.fit", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.IsolationForestDetector.predict", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.predict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.IsolationForestDetector.decision_function", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.decision_function", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.IsolationForestDetector.fit_predict", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.fit_predict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.IsolationForestDetector.get_anomalies", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.get_anomalies", "kind": "function", "doc": "<p>Get the anomalies in the dataset X.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : array-like of shape (n_samples, n_features)\nThe input samples.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>anomalies : array-like of shape (n_anomalies, n_features)\nThe anomalies found in the dataset.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.IsolationForestDetector.predict_proba", "modulename": "sla.detectors", "qualname": "IsolationForestDetector.predict_proba", "kind": "function", "doc": "<p>Predict the probability of each sample being an anomaly.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : array-like of shape (n_samples, n_features)\n    The input samples.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>proba : array-like of shape (n_samples,)\n    The probability of each sample being an anomaly.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.RRCFDetector", "modulename": "sla.detectors", "qualname": "RRCFDetector", "kind": "class", "doc": "<p>Robust Random Cut Forest anomaly detector.</p>\n\n<p>Esta clase implementa la detecci\u00f3n de anomal\u00edas utilizando el algoritmo\nRobust Random Cut Forest para la detecci\u00f3n de anomal\u00edas en streaming.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>shingle_size : int, default=15\n    Tama\u00f1o de la ventana de shingling.\nnum_trees : int, default=100\n    N\u00famero de \u00e1rboles en el bosque aleatorio.\ntree_size : int, default=500\n    Tama\u00f1o m\u00e1ximo de cada \u00e1rbol en el bosque.</p>\n", "bases": "sklearn.base.BaseEstimator"}, {"fullname": "sla.detectors.RRCFDetector.__init__", "modulename": "sla.detectors", "qualname": "RRCFDetector.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shingle_size</span><span class=\"o\">=</span><span class=\"mi\">15</span>, </span><span class=\"param\"><span class=\"n\">num_trees</span><span class=\"o\">=</span><span class=\"mi\">100</span>, </span><span class=\"param\"><span class=\"n\">tree_size</span><span class=\"o\">=</span><span class=\"mi\">500</span></span>)</span>"}, {"fullname": "sla.detectors.RRCFDetector.shingle_size", "modulename": "sla.detectors", "qualname": "RRCFDetector.shingle_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.RRCFDetector.num_trees", "modulename": "sla.detectors", "qualname": "RRCFDetector.num_trees", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.RRCFDetector.tree_size", "modulename": "sla.detectors", "qualname": "RRCFDetector.tree_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.RRCFDetector.forest", "modulename": "sla.detectors", "qualname": "RRCFDetector.forest", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.RRCFDetector.index", "modulename": "sla.detectors", "qualname": "RRCFDetector.index", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.RRCFDetector.anomaly_scores", "modulename": "sla.detectors", "qualname": "RRCFDetector.anomaly_scores", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.RRCFDetector.fit", "modulename": "sla.detectors", "qualname": "RRCFDetector.fit", "kind": "function", "doc": "<p>Fit the model to the input data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : array-like of shape (n_samples,)\n    Input time series data.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>self : object\n    Returns self.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.RRCFDetector.predict", "modulename": "sla.detectors", "qualname": "RRCFDetector.predict", "kind": "function", "doc": "<p>Calculate anomaly scores for input data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : array-like of shape (n_samples,)\n    Input time series data.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>scores : ndarray of shape (n_samples,)\n    Anomaly scores for each input sample.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.RRCFDetector.fit_predict", "modulename": "sla.detectors", "qualname": "RRCFDetector.fit_predict", "kind": "function", "doc": "<p>Fit the model and calculate anomaly scores.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : array-like of shape (n_samples,)\n    Input time series data.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>anomaly_scores : Series of shape (n_samples,)\n    Anomaly scores for each input sample.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.RRCFDetector.get_anomalies", "modulename": "sla.detectors", "qualname": "RRCFDetector.get_anomalies", "kind": "function", "doc": "<p>Identify anomalies based on a threshold.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>threshold : float\n    Threshold value for anomaly detection.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>anomalies : Series\n    Series containing anomaly scores above the threshold.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.RRCFDetector.predict_proba", "modulename": "sla.detectors", "qualname": "RRCFDetector.predict_proba", "kind": "function", "doc": "<p>Calculate normalized probability-like anomaly scores.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : array-like of shape (n_samples,)\n    Input time series data.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>proba : ndarray of shape (n_samples,)\n    Normalized anomaly scores.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.LNNDetector", "modulename": "sla.detectors", "qualname": "LNNDetector", "kind": "class", "doc": "<p>LNN-based autoencoder anomaly detector.</p>\n\n<p>This class implements an anomaly detector using a Liquid Neural Network-based\nautoencoder for detecting anomalies in time series data, offering improved \ncapability for handling complex temporal dynamics.</p>\n"}, {"fullname": "sla.detectors.LNNDetector.__init__", "modulename": "sla.detectors", "qualname": "LNNDetector.__init__", "kind": "function", "doc": "<p>Initialize the LNN-based anomaly detector.</p>\n\n<p>Args:\n    n_features (int): Dimension of input features\n    seq_len (int): Length of input sequence\n    latent_dim (int): Dimension of the latent space representation\n    learning_rate (float): Learning rate for training the model\n    epochs (int): Number of epochs for training the model\n    threshold_multiplier (float): Anomaly threshold multiplier</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_features</span>,</span><span class=\"param\">\t<span class=\"n\">seq_len</span>,</span><span class=\"param\">\t<span class=\"n\">latent_dim</span><span class=\"o\">=</span><span class=\"mi\">8</span>,</span><span class=\"param\">\t<span class=\"n\">learning_rate</span><span class=\"o\">=</span><span class=\"mf\">0.001</span>,</span><span class=\"param\">\t<span class=\"n\">epochs</span><span class=\"o\">=</span><span class=\"mi\">20</span>,</span><span class=\"param\">\t<span class=\"n\">threshold_multiplier</span><span class=\"o\">=</span><span class=\"mf\">3.0</span></span>)</span>"}, {"fullname": "sla.detectors.LNNDetector.n_features", "modulename": "sla.detectors", "qualname": "LNNDetector.n_features", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.seq_len", "modulename": "sla.detectors", "qualname": "LNNDetector.seq_len", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.latent_dim", "modulename": "sla.detectors", "qualname": "LNNDetector.latent_dim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.learning_rate", "modulename": "sla.detectors", "qualname": "LNNDetector.learning_rate", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.epochs", "modulename": "sla.detectors", "qualname": "LNNDetector.epochs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.threshold_multiplier", "modulename": "sla.detectors", "qualname": "LNNDetector.threshold_multiplier", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.device", "modulename": "sla.detectors", "qualname": "LNNDetector.device", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.model", "modulename": "sla.detectors", "qualname": "LNNDetector.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.optimizer", "modulename": "sla.detectors", "qualname": "LNNDetector.optimizer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.criterion", "modulename": "sla.detectors", "qualname": "LNNDetector.criterion", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.scaler", "modulename": "sla.detectors", "qualname": "LNNDetector.scaler", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.threshold", "modulename": "sla.detectors", "qualname": "LNNDetector.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.history", "modulename": "sla.detectors", "qualname": "LNNDetector.history", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.detectors.LNNDetector.fit", "modulename": "sla.detectors", "qualname": "LNNDetector.fit", "kind": "function", "doc": "<p>Fit the LNN-based anomaly detector to the input data.</p>\n\n<p>Args:\n    X (np.ndarray): Input data for training the model\n    X_test (np.ndarray, optional): Test data for validation\n    verbose (bool): Whether to print training progress</p>\n\n<p>Returns:\n    dict: Training history</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">X_test</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.LNNDetector.predict", "modulename": "sla.detectors", "qualname": "LNNDetector.predict", "kind": "function", "doc": "<p>Predict anomalies in the input data.</p>\n\n<p>Args:\n    X (np.ndarray): Input data for anomaly detection</p>\n\n<p>Returns:\n    np.ndarray: Binary array where 1 indicates anomaly, 0 indicates normal</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.LNNDetector.anomaly_score", "modulename": "sla.detectors", "qualname": "LNNDetector.anomaly_score", "kind": "function", "doc": "<p>Calculate anomaly scores for the input data.</p>\n\n<p>Args:\n    X (np.ndarray): Input data for anomaly detection</p>\n\n<p>Returns:\n    np.ndarray: Anomaly scores (reconstruction errors)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.LNNDetector.save_model", "modulename": "sla.detectors", "qualname": "LNNDetector.save_model", "kind": "function", "doc": "<p>Save the model to disk.</p>\n\n<p>Args:\n    path (str): File path to save the model</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.detectors.LNNDetector.load_model", "modulename": "sla.detectors", "qualname": "LNNDetector.load_model", "kind": "function", "doc": "<p>Load the model from disk.</p>\n\n<p>Args:\n    path (str): File path to load the model</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer", "modulename": "sla.explorer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.explorer.conftest", "modulename": "sla.explorer.conftest", "kind": "module", "doc": "<p>Pytest configuration module for analyzer.</p>\n\n<p>This module defines fixtures and hooks used for testing data analysis\nwith labeled events. It handles loading CSV data, applying event labels,\nand improving test failure reporting.</p>\n\n<p>Example usage:\n    pytest run_tests.py --csvpath=data_file.csv --columns=column1,column2 --events_csvpath=events_file.csv --html=report.html</p>\n"}, {"fullname": "sla.explorer.conftest.pytest_addoption", "modulename": "sla.explorer.conftest", "qualname": "pytest_addoption", "kind": "function", "doc": "<p>Add command line options to pytest.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>parser : _pytest.config.argparsing.Parser\n    Pytest command line parser to which the options are added.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.conftest.df_and_columns", "modulename": "sla.explorer.conftest", "qualname": "df_and_columns", "kind": "function", "doc": "<p>Fixture to load and prepare dataframes with event labels.</p>\n\n<p>Reads a CSV file of time-series data and optionally applies event labels\nbased on a second CSV containing event time periods.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>request : pytest.FixtureRequest\n    The pytest request object for accessing command line options.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple\n    A tuple containing (dataframe, columns_list) with the loaded and\n    labeled dataframe and list of column names for testing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">request</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.conftest.pytest_runtest_makereport", "modulename": "sla.explorer.conftest", "qualname": "pytest_runtest_makereport", "kind": "function", "doc": "<p>Pytest hook for enhancing test failure reports.</p>\n\n<p>Captures stdout and stderr output during test execution and includes\nit in the test report when a test fails.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>item : pytest.Item\n    Test item being executed.\ncall : pytest.CallInfo\n    Information about the test execution.</p>\n\n<h2 id=\"yields\">Yields</h2>\n\n<p>_pytest.runner.CallInfo\n    The call info outcome for further processing by pytest.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">item</span>, </span><span class=\"param\"><span class=\"n\">call</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.run_tests", "modulename": "sla.explorer.run_tests", "kind": "module", "doc": "<p>Test suite for SLA data analysis.</p>\n\n<p>This module provides test functions for validating data quality and relevance\nfor anomaly detection. Tests verify data completeness, presence of anomalies,\nstatistical properties, and predictive capability of features.</p>\n"}, {"fullname": "sla.explorer.run_tests.detect_anomalies", "modulename": "sla.explorer.run_tests", "qualname": "detect_anomalies", "kind": "function", "doc": "<p>Detect outliers in a DataFrame column using the IQR method.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df : pandas.DataFrame\n    DataFrame containing the data to analyze\ncolumn : str\n    Name of the column to check for anomalies</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas.DataFrame\n    Subset of the original DataFrame containing only the anomalies</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">column</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.run_tests.test_minimum_entries", "modulename": "sla.explorer.run_tests", "qualname": "test_minimum_entries", "kind": "function", "doc": "<p>Test that each column has a minimum number of non-null entries.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_and_columns : tuple\n    Tuple containing (DataFrame, list of column names)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_and_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.run_tests.test_column_names", "modulename": "sla.explorer.run_tests", "qualname": "test_column_names", "kind": "function", "doc": "<p>Test that the DataFrame contains the required 'label' column.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_and_columns : tuple\n    Tuple containing (DataFrame, list of column names)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_and_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.run_tests.test_anomalies", "modulename": "sla.explorer.run_tests", "qualname": "test_anomalies", "kind": "function", "doc": "<p>Test that each column contains a minimum percentage of anomalies.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_and_columns : tuple\n    Tuple containing (DataFrame, list of column names)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_and_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.run_tests.test_non_null_percentage", "modulename": "sla.explorer.run_tests", "qualname": "test_non_null_percentage", "kind": "function", "doc": "<p>Test that each column has a minimum percentage of non-null values.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_and_columns : tuple\n    Tuple containing (DataFrame, list of column names)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_and_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.run_tests.test_column_variance", "modulename": "sla.explorer.run_tests", "qualname": "test_column_variance", "kind": "function", "doc": "<p>Test that each column has sufficient variance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_and_columns : tuple\n    Tuple containing (DataFrame, list of column names)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_and_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.run_tests.test_value_label_correlation", "modulename": "sla.explorer.run_tests", "qualname": "test_value_label_correlation", "kind": "function", "doc": "<p>Test correlation between column values and event labels.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_and_columns : tuple\n    Tuple containing (DataFrame, list of column names)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_and_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.explorer.run_tests.test_logistic_regression_recall", "modulename": "sla.explorer.run_tests", "qualname": "test_logistic_regression_recall", "kind": "function", "doc": "<p>Test predictive capability of each column using logistic regression.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_and_columns : tuple\n    Tuple containing (DataFrame, list of column names)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_and_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.ingestion", "modulename": "sla.ingestion", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.base_parser", "modulename": "sla.ingestion.base_parser", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.base_parser.BaseLogParser", "modulename": "sla.ingestion.base_parser", "qualname": "BaseLogParser", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "sla.ingestion.base_parser.BaseLogParser.file_path", "modulename": "sla.ingestion.base_parser", "qualname": "BaseLogParser.file_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.base_parser.BaseLogParser.parse", "modulename": "sla.ingestion.base_parser", "qualname": "BaseLogParser.parse", "kind": "function", "doc": "<p>Patr\u00f3n de Dise\u00f1o de tipo Abstract Factory\nM\u00e9todo abstracto que debe ser implementado por las subclases.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.ingestion.hdc_parser", "modulename": "sla.ingestion.hdc_parser", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.hdc_parser.LOG_PATTERN", "modulename": "sla.ingestion.hdc_parser", "qualname": "LOG_PATTERN", "kind": "variable", "doc": "<p></p>\n", "default_value": "re.compile(&#x27;\\\\[(\\\\d{2}/\\\\d{2}/\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2}:\\\\d{3}) COT\\\\]\\\\s+(\\\\w+)\\\\s+(\\\\w+)\\\\s+(\\\\w)\\\\s+(.+)&#x27;, re.DOTALL)"}, {"fullname": "sla.ingestion.hdc_parser.extract_error_code", "modulename": "sla.ingestion.hdc_parser", "qualname": "extract_error_code", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">description</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.ingestion.hdc_parser.HDCParser", "modulename": "sla.ingestion.hdc_parser", "qualname": "HDCParser", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "sla.ingestion.base_parser.BaseLogParser"}, {"fullname": "sla.ingestion.hdc_parser.HDCParser.parse", "modulename": "sla.ingestion.hdc_parser", "qualname": "HDCParser.parse", "kind": "function", "doc": "<p>Patr\u00f3n de Dise\u00f1o de tipo Abstract Factory\nM\u00e9todo abstracto que debe ser implementado por las subclases.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.ingestion.hsm_parser", "modulename": "sla.ingestion.hsm_parser", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.hsm_parser.HSMParser", "modulename": "sla.ingestion.hsm_parser", "qualname": "HSMParser", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "sla.ingestion.base_parser.BaseLogParser"}, {"fullname": "sla.ingestion.hsm_parser.HSMParser.parse", "modulename": "sla.ingestion.hsm_parser", "qualname": "HSMParser.parse", "kind": "function", "doc": "<p>Patr\u00f3n de Dise\u00f1o de tipo Abstract Factory\nM\u00e9todo abstracto que debe ser implementado por las subclases.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.ingestion.ibmmq_parser", "modulename": "sla.ingestion.ibmmq_parser", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.ibmmq_parser.IBMMQParser", "modulename": "sla.ingestion.ibmmq_parser", "qualname": "IBMMQParser", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "sla.ingestion.base_parser.BaseLogParser"}, {"fullname": "sla.ingestion.ibmmq_parser.IBMMQParser.parse", "modulename": "sla.ingestion.ibmmq_parser", "qualname": "IBMMQParser.parse", "kind": "function", "doc": "<p>Patr\u00f3n de Dise\u00f1o de tipo Abstract Factory\nM\u00e9todo abstracto que debe ser implementado por las subclases.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.ingestion.ingestor", "modulename": "sla.ingestion.ingestor", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.ingestor.LogIngestor", "modulename": "sla.ingestion.ingestor", "qualname": "LogIngestor", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.ingestor.LogIngestor.parsers", "modulename": "sla.ingestion.ingestor", "qualname": "LogIngestor.parsers", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;HSM&#x27;: &lt;class &#x27;sla.ingestion.hsm_parser.HSMParser&#x27;&gt;, &#x27;HDC&#x27;: &lt;class &#x27;sla.ingestion.hdc_parser.HDCParser&#x27;&gt;, &#x27;IBM_MQ&#x27;: &lt;class &#x27;sla.ingestion.ibmmq_parser.IBMMQParser&#x27;&gt;, &#x27;WAS&#x27;: &lt;class &#x27;sla.ingestion.was_parser.WASParser&#x27;&gt;}"}, {"fullname": "sla.ingestion.ingestor.LogIngestor.ingest", "modulename": "sla.ingestion.ingestor", "qualname": "LogIngestor.ingest", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">log_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.ingestion.was_parser", "modulename": "sla.ingestion.was_parser", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.ingestion.was_parser.WASParser", "modulename": "sla.ingestion.was_parser", "qualname": "WASParser", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "sla.ingestion.base_parser.BaseLogParser"}, {"fullname": "sla.ingestion.was_parser.WASParser.parse", "modulename": "sla.ingestion.was_parser", "qualname": "WASParser.parse", "kind": "function", "doc": "<p>Patr\u00f3n de Dise\u00f1o de tipo Abstract Factory\nM\u00e9todo abstracto que debe ser implementado por las subclases.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.simulation", "modulename": "sla.simulation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation", "modulename": "sla.simulation", "qualname": "StreamingSimulation", "kind": "class", "doc": "<p>Module: streaming_anomaly_detection</p>\n\n<p>This module contains the <code>StreamingSimulation</code> class, which simulates real-time data streaming, processes the data for anomaly detection, and visualizes the results. It integrates a streaming data manager, an anomaly detector, and event-based visualization.</p>\n\n<p>Classes:\n    - StreamingSimulation: Simulates real-time data streaming, processes data for anomaly detection, and visualizes results.</p>\n\n<p>Class StreamingSimulation:\n    Simulates real-time data streaming, processes data for anomaly detection, and visualizes results.</p>\n\n<pre><code>Attributes:\n    window_size (int): The size of the sliding window for anomaly detection.\n    threshold (float): The static threshold for anomaly detection.\n    dynamic_threshold (bool): Whether to use a dynamic threshold based on historical scores.\n    percentile (int): The percentile used for calculating the dynamic threshold.\n    manager (StreamingDataManager): Manages the streaming of data chunks.\n    detector (AnomalyDetector): Detects anomalies in the data.\n    historical_data (pd.DataFrame): Stores historical data for processing.\n    historical_scores (list): Stores historical anomaly scores.\n    data_source (pd.DataFrame): The source data for streaming.\n    chunk_size (int): The size of each data chunk for streaming.\n    stream_interval (int): The interval (in seconds) between streaming chunks.\n    queue (queue.Queue): Queue for storing data chunks to be processed.\n    plot_queue (queue.Queue): Queue for storing data to be plotted.\n    streaming_active (bool): Indicates whether the streaming simulation is active.\n    events (pd.DataFrame): DataFrame containing event start and end times, colors, and labels.\n\nMethods:\n    __init__(data: pd.DataFrame, chunk_size=100, stream_interval=1, window_size=120, threshold=0.15, dynamic_threshold=False, percentile=95, events=None):\n        Initializes the StreamingSimulation instance with the given parameters.\n\n    preprocess(chunk: pd.DataFrame) -&gt; np.ndarray:\n        Preprocesses a data chunk by selecting numeric columns and filling missing values.\n\n    _calculate_dynamic_threshold() -&gt; float:\n        Calculates the dynamic threshold based on the specified percentile of historical scores.\n\n    _stream_data():\n        Simulates real-time data streaming by adding data chunks to the queue.\n\n    _plot_from_main_thread():\n        Continuously plots data and anomaly scores from the main thread, including event visualization.\n\n    process_stream():\n        Consumes data from the queue, processes it with the anomaly detector, and updates historical data and scores.\n\n    run():\n        Starts the streaming, processing, and plotting threads. Handles graceful shutdown on interruption.\n</code></pre>\n"}, {"fullname": "sla.simulation.StreamingSimulation.__init__", "modulename": "sla.simulation", "qualname": "StreamingSimulation.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_size</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">stream_interval</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">window_size</span><span class=\"o\">=</span><span class=\"mi\">120</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.15</span>,</span><span class=\"param\">\t<span class=\"n\">dynamic_threshold</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">percentile</span><span class=\"o\">=</span><span class=\"mi\">95</span>,</span><span class=\"param\">\t<span class=\"n\">events</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "sla.simulation.StreamingSimulation.window_size", "modulename": "sla.simulation", "qualname": "StreamingSimulation.window_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.threshold", "modulename": "sla.simulation", "qualname": "StreamingSimulation.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.dynamic_threshold", "modulename": "sla.simulation", "qualname": "StreamingSimulation.dynamic_threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.percentile", "modulename": "sla.simulation", "qualname": "StreamingSimulation.percentile", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.manager", "modulename": "sla.simulation", "qualname": "StreamingSimulation.manager", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.detector", "modulename": "sla.simulation", "qualname": "StreamingSimulation.detector", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.historical_data", "modulename": "sla.simulation", "qualname": "StreamingSimulation.historical_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.historical_scores", "modulename": "sla.simulation", "qualname": "StreamingSimulation.historical_scores", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.data_source", "modulename": "sla.simulation", "qualname": "StreamingSimulation.data_source", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.chunk_size", "modulename": "sla.simulation", "qualname": "StreamingSimulation.chunk_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.stream_interval", "modulename": "sla.simulation", "qualname": "StreamingSimulation.stream_interval", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.queue", "modulename": "sla.simulation", "qualname": "StreamingSimulation.queue", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.plot_queue", "modulename": "sla.simulation", "qualname": "StreamingSimulation.plot_queue", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.streaming_active", "modulename": "sla.simulation", "qualname": "StreamingSimulation.streaming_active", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.events", "modulename": "sla.simulation", "qualname": "StreamingSimulation.events", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.simulation.StreamingSimulation.preprocess", "modulename": "sla.simulation", "qualname": "StreamingSimulation.preprocess", "kind": "function", "doc": "<p>Preprocesses a chunk of data by selecting numeric columns and filling NaN values with 0.</p>\n\n<p>Args:\n    chunk (pd.DataFrame): The input DataFrame containing the data to preprocess.</p>\n\n<p>Returns:\n    np.ndarray: A NumPy array containing the preprocessed numeric data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">chunk</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.simulation.StreamingSimulation.process_stream", "modulename": "sla.simulation", "qualname": "StreamingSimulation.process_stream", "kind": "function", "doc": "<p>Consume data from the queue and process it with the anomaly detector.</p>\n\n<p>This method continuously retrieves data chunks from a queue, processes them,\nand performs anomaly detection using a pre-trained detector. The results are\nthen prepared for visualization and sent to a plotting queue.</p>\n\n<p>Workflow:</p>\n\n<ul>\n<li>Retrieve a chunk of data from the queue.</li>\n<li>Append the chunk to the historical data, maintaining a rolling window of the last 5000 records.</li>\n<li>Preprocess the data for anomaly detection.</li>\n<li>Train the anomaly detector if it is not already trained and sufficient data is available.</li>\n<li>Perform anomaly detection on the current chunk if the detector is trained.</li>\n<li>Update historical scores and count the number of anomalies detected in the current chunk.</li>\n<li>Filter historical data and scores to include only the last three hours of data.</li>\n<li>Send the filtered data and scores to the plotting queue for visualization.</li>\n</ul>\n\n<p>Exceptions:</p>\n\n<ul>\n<li>Handles <code>queue.Empty</code> exceptions when the queue is empty and continues processing.</li>\n<li>Catches and logs any other exceptions that occur during processing.</li>\n</ul>\n\n<p>Attributes:</p>\n\n<ul>\n<li>self.streaming_active (bool): Flag to control the streaming process.</li>\n<li>self.queue (queue.Queue): Queue from which data chunks are consumed.</li>\n<li>self.historical_data (pd.DataFrame): DataFrame storing historical data for processing.</li>\n<li>self.historical_scores (np.ndarray): Array storing historical anomaly scores.</li>\n<li>self.window_size (int): Size of the rolling window for preprocessing.</li>\n<li>self.detector (object): Anomaly detector instance with <code>fit</code> and <code>detect</code> methods.</li>\n<li>self.plot_queue (queue.Queue): Queue to send data and scores for visualization.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.simulation.StreamingSimulation.run", "modulename": "sla.simulation", "qualname": "StreamingSimulation.run", "kind": "function", "doc": "<p>Executes the streaming anomaly detection simulation.\nThis method starts two separate threads:</p>\n\n<ol>\n<li>A streaming thread that simulates or handles incoming data.</li>\n<li>A processing thread that processes the streamed data.\nThe simulation remains active until interrupted by a KeyboardInterrupt\n(e.g., pressing Ctrl+C). Upon interruption, the simulation stops gracefully\nby setting <code>self.streaming_active</code> to False and joining both threads.\nAdditionally, this method handles plotting from the main thread.\nRaises:\nKeyboardInterrupt: If the simulation is manually stopped by the user.</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.transformer", "modulename": "sla.transformer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator", "modulename": "sla.transformer", "qualname": "RollingAgregator", "kind": "class", "doc": "<p>Rolling aggregate transformer for anomaly detection pipelines.</p>\n\n<p>This transformer computes rolling window aggregations on time series data,\nsuitable for use in scikit-learn pipelines for anomaly detection.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>window_size : int\n    Size of the rolling window.\naggregation_functions : str, callable, or list, default='mean'\n    Functions to apply to the rolling window. Can be:\n    - String naming a pandas rolling method ('mean', 'std', etc.)\n    - Callable function to apply to each window\n    - List of strings or callables for multiple aggregations\ncolumns : str or list of str, optional\n    Specific columns to apply rolling aggregations to.\n    If None, applies to all numeric columns.\nwindow_type : str, optional\n    Type of window ('fixed', 'expanding', or 'ewm').\n    Fixed rolling window (traditional rolling window)\n    Expanding window (growing window size)\n    Exponentially weighted moving window (EWMA)\nmin_periods : int, optional\n    Minimum number of observations required to have a value.\n    If None, defaults to window_size.\ncenter : bool, default=False\n    If True, the window will be centered around the current point.\nsuffix : str, default='_rolling'\n    Suffix to append to column names for the new features.\nkwargs : dict\n    Additional keyword arguments to pass to the rolling function.</p>\n", "bases": "sklearn.base.BaseEstimator, sklearn.base.TransformerMixin"}, {"fullname": "sla.transformer.RollingAgregator.__init__", "modulename": "sla.transformer", "qualname": "RollingAgregator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">window_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">aggregation_functions</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;mean&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">window_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;fixed&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">min_periods</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">center</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;_rolling&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "sla.transformer.RollingAgregator.window_size", "modulename": "sla.transformer", "qualname": "RollingAgregator.window_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator.aggregation_functions", "modulename": "sla.transformer", "qualname": "RollingAgregator.aggregation_functions", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator.columns", "modulename": "sla.transformer", "qualname": "RollingAgregator.columns", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator.window_type", "modulename": "sla.transformer", "qualname": "RollingAgregator.window_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator.min_periods", "modulename": "sla.transformer", "qualname": "RollingAgregator.min_periods", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator.center", "modulename": "sla.transformer", "qualname": "RollingAgregator.center", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator.suffix", "modulename": "sla.transformer", "qualname": "RollingAgregator.suffix", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator.kwargs", "modulename": "sla.transformer", "qualname": "RollingAgregator.kwargs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.RollingAgregator.fit", "modulename": "sla.transformer", "qualname": "RollingAgregator.fit", "kind": "function", "doc": "<p>Fit the transformer (no-op).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : DataFrame\n    Input data to fit.\ny : array-like or None, default=None\n    Targets. Ignored in this transformer.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>self : RollingAggregateTransformer\n    Returns self.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sla</span><span class=\"o\">.</span><span class=\"n\">transformer</span><span class=\"o\">.</span><span class=\"n\">rolling_aggregate</span><span class=\"o\">.</span><span class=\"n\">RollingAgregator</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.transformer.RollingAgregator.transform", "modulename": "sla.transformer", "qualname": "RollingAgregator.transform", "kind": "function", "doc": "<p>Apply rolling aggregations to the input data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : DataFrame\n    Input data to transform.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame\n    Transformed data with rolling aggregations.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.transformer.RollingAgregator.get_feature_names_out", "modulename": "sla.transformer", "qualname": "RollingAgregator.get_feature_names_out", "kind": "function", "doc": "<p>Get output feature names for transformation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>input_features : array-like of str or None, default=None\n    Input features. Ignored in this transformer.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>list of str\n    Output feature names.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">input_features</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.transformer.RollingAgregator.fit_transform", "modulename": "sla.transformer", "qualname": "RollingAgregator.fit_transform", "kind": "function", "doc": "<p>Fit and transform in one step.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : DataFrame\n    Input data to fit and transform.\ny : array-like or None, default=None\n    Targets. Ignored in this transformer.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame\n    Transformed data with rolling aggregations.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.transformer.StringAggregator", "modulename": "sla.transformer", "qualname": "StringAggregator", "kind": "class", "doc": "<p>Clase para realizar agregaciones flexibles en DataFrames con soporte para ventanas temporales.</p>\n\n<p>Permite definir m\u00e9tricas personalizadas para cualquier tipo de columna.</p>\n"}, {"fullname": "sla.transformer.StringAggregator.__init__", "modulename": "sla.transformer", "qualname": "StringAggregator.__init__", "kind": "function", "doc": "<p>Inicializa el agregador con un DataFrame y columna de timestamp.</p>\n\n<p>Args:\n    dataframe (pd.DataFrame): DataFrame de entrada\n    timestamp_column (str): Nombre de la columna de timestamp</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataframe</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">timestamp_column</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "sla.transformer.StringAggregator.df", "modulename": "sla.transformer", "qualname": "StringAggregator.df", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.StringAggregator.timestamp_column", "modulename": "sla.transformer", "qualname": "StringAggregator.timestamp_column", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.transformer.StringAggregator.create_time_aggregation", "modulename": "sla.transformer", "qualname": "StringAggregator.create_time_aggregation", "kind": "function", "doc": "<p>Realiza agregaciones flexibles por ventana de tiempo.</p>\n\n<p>Args:\n    time_window (str, optional): Ventana temporal. Defaults to '5min'.\n    column_metrics (Dict[str, List], optional): M\u00e9tricas para columnas espec\u00edficas.\n    custom_metrics (Dict[str, Callable], optional): M\u00e9tricas personalizadas.\n    category_count_columns (Dict[str, List[str]], optional): Columnas para conteo por categor\u00eda.</p>\n\n<p>Returns:\n    pd.DataFrame: DataFrame con agregaciones</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">time_window</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;5min&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">column_metrics</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">custom_metrics</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">category_count_columns</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "sla.visualization", "modulename": "sla.visualization", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sla.visualization.AnomalyVisualizer", "modulename": "sla.visualization", "qualname": "AnomalyVisualizer", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "sla.visualization.AnomalyVisualizer.__init__", "modulename": "sla.visualization", "qualname": "AnomalyVisualizer.__init__", "kind": "function", "doc": "<p>Initializes the AnomalyVisualizer.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>anomaly_df (DataFrame): DataFrame containing anomaly data.</li>\n<li>incidents_df (DataFrame): DataFrame containing incident data (optional).</li>\n<li>score_col (str): Column name for anomaly scores (default: 'scores').</li>\n<li>anomaly_col (str): Column name for anomaly labels (default: 'anomaly').</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">anomaly_df</span>,</span><span class=\"param\">\t<span class=\"n\">incidents_df</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">score_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;scores&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">anomaly_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;anomaly&#39;</span></span>)</span>"}, {"fullname": "sla.visualization.AnomalyVisualizer.anomaly_df", "modulename": "sla.visualization", "qualname": "AnomalyVisualizer.anomaly_df", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.visualization.AnomalyVisualizer.incidents_df", "modulename": "sla.visualization", "qualname": "AnomalyVisualizer.incidents_df", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.visualization.AnomalyVisualizer.score_col", "modulename": "sla.visualization", "qualname": "AnomalyVisualizer.score_col", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.visualization.AnomalyVisualizer.anomaly_col", "modulename": "sla.visualization", "qualname": "AnomalyVisualizer.anomaly_col", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.visualization.AnomalyVisualizer.plot_static", "modulename": "sla.visualization", "qualname": "AnomalyVisualizer.plot_static", "kind": "function", "doc": "<p>Plots a static graph using matplotlib.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>zoom (bool): Whether to zoom into a specific date range.</li>\n<li>zoom_date (list): List of two dates [start_date, end_date] for zooming.</li>\n<li>colors (dict): Custom colors for 'normal', 'anomaly', and 'incident'.</li>\n<li>title (str): Title of the plot.</li>\n<li>xlabel (str): Label for the x-axis.</li>\n<li>ylabel (str): Label for the y-axis.</li>\n<li>legend_labels (list): Custom labels for the legend.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">zoom</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">zoom_date</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">colors</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">xlabel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ylabel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">legend_labels</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.visualization.AnomalyVisualizer.plot_dynamic", "modulename": "sla.visualization", "qualname": "AnomalyVisualizer.plot_dynamic", "kind": "function", "doc": "<p>Plots a dynamic graph using Plotly.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>colors (dict): Custom colors for 'normal', 'anomaly', and 'incident'.</li>\n<li>title (str): Title of the plot.</li>\n<li>xaxis_title (str): Label for the x-axis.</li>\n<li>yaxis_title (str): Label for the y-axis.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">colors</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">xaxis_title</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">yaxis_title</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.visualization.SHAPVisualizer", "modulename": "sla.visualization", "qualname": "SHAPVisualizer", "kind": "class", "doc": "<p>A visualizer for SHAP values to explain the predictions of the IsolationForestDetector.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : IsolationForestDetector\n    The trained IsolationForestDetector model.</p>\n"}, {"fullname": "sla.visualization.SHAPVisualizer.__init__", "modulename": "sla.visualization", "qualname": "SHAPVisualizer.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span></span>)</span>"}, {"fullname": "sla.visualization.SHAPVisualizer.model", "modulename": "sla.visualization", "qualname": "SHAPVisualizer.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.visualization.SHAPVisualizer.explainer", "modulename": "sla.visualization", "qualname": "SHAPVisualizer.explainer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sla.visualization.SHAPVisualizer.plot_force", "modulename": "sla.visualization", "qualname": "SHAPVisualizer.plot_force", "kind": "function", "doc": "<p>Plots a SHAP force plot for a specific anomaly.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : array-like of shape (n_samples, n_features)\n    The input samples.\nanomaly_index : int\n    The index of the anomaly in the dataset X to visualize.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">anomaly_index</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sla.visualization.SHAPVisualizer.plot_summary", "modulename": "sla.visualization", "qualname": "SHAPVisualizer.plot_summary", "kind": "function", "doc": "<p>Plots a SHAP summary plot for the dataset.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X : array-like of shape (n_samples, n_features)\n    The input samples.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();